{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Creative Drive Development REST API Guidelines Standards Introduction RESTful APIs are interfaces that enable applications to communicate with each other. The role of REST APIs has expanded dramatically, where even major companies, such as Facebook, Google, Github, Netflix and a few other tech giants have given access to developers and products to consume their data through APIs, and even became a platform for them. They can be used as an interface to the business, allowing them to monetize digital assets, extend their value proposition with partner-delivered capabilities, and connect to customers across multiple channels, tools, and devices. Creative Drive seeks to do the same across our own suite of applications and products. In order to achieve this goal while utilizing multiple development teams and products, a uniform Guidelines Standards protocol is required. Development Topics This document will cover the following General REST API Development areas, as well as the Creative Drive Standards and Guidelines. General REST API Guidelines General API Rules - Ensuring Consistency and Compatibility of the API. Terminologies - What are Resources, Collections, Endpoints, and others Methods - The differences between GET, POST, PUT, DELETE, etc Status Codes - part of the HTTP/1.1 standard (RFC 7231) Option Parameter Queries - appending query params with the GET method Creative Drive Standards Error Response Structure - Descriptive outputs that allows for problem solving Versioning - Handling Breaking changes Authentication - REST API Security New Endpoints - How to add a new Route / Collections Synchronous Asynchronous Calls - Adding Synchronous and Asynchronous calls Contributing Documentation and Reference Material RFC 7231 RFC 7807 List of HTTP Status Codes, Wikipedia HTTP Method Definitions API Glossary RESTful API Design Best Practices, by Philipp Hauer Top REST API Best Practices, code-maze.com Secrets of a Great API, Mulesoft API Design Guidelines, Hackernoon.com","title":"Home"},{"location":"#creative-drive-development-rest-api-guidelines-standards","text":"","title":"Creative Drive Development REST API Guidelines &amp; Standards"},{"location":"#introduction","text":"RESTful APIs are interfaces that enable applications to communicate with each other. The role of REST APIs has expanded dramatically, where even major companies, such as Facebook, Google, Github, Netflix and a few other tech giants have given access to developers and products to consume their data through APIs, and even became a platform for them. They can be used as an interface to the business, allowing them to monetize digital assets, extend their value proposition with partner-delivered capabilities, and connect to customers across multiple channels, tools, and devices. Creative Drive seeks to do the same across our own suite of applications and products. In order to achieve this goal while utilizing multiple development teams and products, a uniform Guidelines Standards protocol is required.","title":"Introduction"},{"location":"#development-topics","text":"This document will cover the following General REST API Development areas, as well as the Creative Drive Standards and Guidelines.","title":"Development Topics"},{"location":"#general-rest-api-guidelines","text":"General API Rules - Ensuring Consistency and Compatibility of the API. Terminologies - What are Resources, Collections, Endpoints, and others Methods - The differences between GET, POST, PUT, DELETE, etc Status Codes - part of the HTTP/1.1 standard (RFC 7231) Option Parameter Queries - appending query params with the GET method","title":"General REST API Guidelines"},{"location":"#creative-drive-standards","text":"Error Response Structure - Descriptive outputs that allows for problem solving Versioning - Handling Breaking changes Authentication - REST API Security New Endpoints - How to add a new Route / Collections Synchronous Asynchronous Calls - Adding Synchronous and Asynchronous calls","title":"Creative Drive Standards"},{"location":"#contributing-documentation-and-reference-material","text":"RFC 7231 RFC 7807 List of HTTP Status Codes, Wikipedia HTTP Method Definitions API Glossary RESTful API Design Best Practices, by Philipp Hauer Top REST API Best Practices, code-maze.com Secrets of a Great API, Mulesoft API Design Guidelines, Hackernoon.com","title":"Contributing Documentation and Reference Material"},{"location":"authentication/","text":"In order to validate the user credentials the caller should include the token provided by the Authorization Service. For that purpose it should be passed as the Authorization header field. The API will check this field for each request Additionally, the authorization formatting needs to one of 2 accepted structures: via Static Authorization token in the database, such as: Authorization=apitestkey via user Bearer token, , such as: Authorization=Bearer eyJ0eXAiOiJCZWFyZXIiLCJhbGciOiJIUzUx... Here's an example of API request with the Authorization header highlighted: Request method: PUT Request URI: https://staging-my-api.creativedrive.com/v 1 /ui/ 2 Proxy: none Request params: none Query params: none Form params: none Path params: none Headers: Authorization=Bearer eyJ 0 eXAiOiJCZWFyZXIiLCJhbGciOiJIUzUxMiIsImp 0 aSI 6 IjQxMzA 3 OGNkZTFkMTc 0 ZTAwMDNlYjkyYmUzNTAzM 2 Q 2 MjFhMDljNzMifQ.eyJqdGkiOiI 0 MTMwNzhjZGUxZDE 3 NGUwMDAzZWI 5 MmJlMzUwMzNkNjIxYTA 5 YzczIiwiaWF 0 IjoxNTQ 3 NzQ 5 NzU 2 LCJuYmYiOjE 1 NDc 3 NDk 3 NTYsImV 4 cCI 6 MTU 0 Nzc 1 MzM 1 NiwiaXNzIjoiYXBpLmNyZWF 0 aXZlZHJpdmUuY 29 tIiwiYXVkIjoiKi 5 jcmVhdGl 2 ZWRyaXZlLmNvbSIsImRhdGEiOnsidXNlcl 9 pZCI 6 MjUyLCJhY 2 NvdW 50 X 2 lkIjpudWxsLCJ 1 c 2 VybmFtZSI 6 bnVsbCwiZW 1 haWwiOiJzdG 9 yZXMuaW 5 zdGFuY 2 UuYWRtaW 5 AY 3 JlYXRpdmVkcml 2 ZS 5 jb 20 iLCJleHRlcm 5 hbF 9 pZCI 6 bnVsbH 0 sInNjb 3 BlcyI 6 eyJhaTkiOlsiQXV 0 aFNlcnZpY 2 UuKiJdLCJhaTMiOlsiQXV 0 aFNlcnZpY 2 UuKiJdfX 0.57 tsbYKHSjY 4 MIKhyAWHQcY-aNOQ_tXw-o 32 bVP 1E1 KcEZ 2 vFucxYtjzhaMwKy 2 aD 1 -k 62 Q 3-4 vq 0 Cu 4 liEM 7 w Accept=*/* Content-Type=application/json; charset=UTF -8 Cookies: none Multiparts: none Body: { data : { auth_domain : staging-my.creativedrive.com , input_field_style : color: #AAA; border-left: 2px solid #000 !important; , page_title : CreativeDrive | User Login , sso_button_type : text , active : true , background_value : https://static.videezy.com/system/resources/previews/000/018/959/original/red.mp4 , sso_button_content : Click to use your Single Sign-On Account , background_type : video , sso_enabled : true , login_title : null , logo : https://www.creativedrive.com/wp-content/themes/creative_drive/img/logos/creativedrive.png , login_btn_style : color: #FFF; border-color:#FFF; background-color:#000 , logo_text : CreativeDrive Logo }, location : { app_name : Share , instance_name : Walmart } } HTTP/ 1.1 202 Successfully updated resource In the case in which the field is missing or the token is not valid, the HTTP response code will be 403 (Forbidden) NOTE : Possibly, in the near future, this checking for all requests will change in favor of allow some actions without the need of an Authorization token.","title":"Authentication"},{"location":"errorhandling/","text":"HTTP status codes are sometimes not sufficient to convey enough information about an error to be helpful. While humans behind browsers can be informed about the nature of the problem with an API response body, non-human consumers of so-called \"HTTP APIs\" are usually not. To address this, we have adopted a minimalistic common error formats for our applications, with elements taken from RFC 7807 . API Error JSON Response Here at Creative Drive, we are using a very simple customized JSON Error response for our APIs. Additionally, For the sake of completeness, also included is the RFC-defined specification for handling error responses. Our Error-defined response { errors : [ { message : Incorrect email or password , code : 401 } ] } errors is the Json object type, followed by an Json Array which contains the error details object. message is the details of the error. This would correspond to the detail section of RFC 7807 . code is the status code that has been returned. The Content-type for all API responses (successful and error alike) is: Content-Type: application/vnd.api+json; The RFC-defined response The \"Official\" RFC-defined JSON Error response looks like thus: HTTP/ 1.1 403 Forbidden Content-Type: application/problem+json Content-Language: en { type : https://example.com/probs/out-of-credit , title : You do not have enough credit. , detail : Your current balance is 30, but that costs 50. , instance : /account/12345/msgs/abc , balance : 30 , accounts : [ /account/12345 , /account/67890 ] } A JSON Error object can have the following members: \"status\" (number) - The HTTP status code ( RFC 7231 , Section 6) generated by the origin server for this occurrence of the problem. In this example, 403 Forbidden \"type\" (string) - A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML. When this member is not present, its value is assumed to be \"about:blank\". \"title\" (string) - A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see ( RFC 7231 , Section 3.4). \"detail\" (string) - A human-readable explanation specific to this occurrence of the problem. \"instance\" (string) - A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced. \"balance\" and \"accounts\" in the example above are EXTRA information that is useful to the user and/or application, and referred to as Extension Members as defined in the RFC 7807 The Content-type is defined as: application/prolem+json as defined in ( RFC spec 7807 , section 6.1) A good read on how other companies, such as Facebook, Spotify, and Google, can be found here: https://blog.restcase.com/rest-api-error-handling-problem-details-response/","title":"Error Response Structure"},{"location":"errorhandling/#api-error-json-response","text":"Here at Creative Drive, we are using a very simple customized JSON Error response for our APIs. Additionally, For the sake of completeness, also included is the RFC-defined specification for handling error responses.","title":"API Error JSON Response"},{"location":"errorhandling/#our-error-defined-response","text":"{ errors : [ { message : Incorrect email or password , code : 401 } ] } errors is the Json object type, followed by an Json Array which contains the error details object. message is the details of the error. This would correspond to the detail section of RFC 7807 . code is the status code that has been returned. The Content-type for all API responses (successful and error alike) is: Content-Type: application/vnd.api+json;","title":"Our Error-defined response"},{"location":"errorhandling/#the-rfc-defined-response","text":"The \"Official\" RFC-defined JSON Error response looks like thus: HTTP/ 1.1 403 Forbidden Content-Type: application/problem+json Content-Language: en { type : https://example.com/probs/out-of-credit , title : You do not have enough credit. , detail : Your current balance is 30, but that costs 50. , instance : /account/12345/msgs/abc , balance : 30 , accounts : [ /account/12345 , /account/67890 ] } A JSON Error object can have the following members: \"status\" (number) - The HTTP status code ( RFC 7231 , Section 6) generated by the origin server for this occurrence of the problem. In this example, 403 Forbidden \"type\" (string) - A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML. When this member is not present, its value is assumed to be \"about:blank\". \"title\" (string) - A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see ( RFC 7231 , Section 3.4). \"detail\" (string) - A human-readable explanation specific to this occurrence of the problem. \"instance\" (string) - A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced. \"balance\" and \"accounts\" in the example above are EXTRA information that is useful to the user and/or application, and referred to as Extension Members as defined in the RFC 7807 The Content-type is defined as: application/prolem+json as defined in ( RFC spec 7807 , section 6.1) A good read on how other companies, such as Facebook, Spotify, and Google, can be found here: https://blog.restcase.com/rest-api-error-handling-problem-details-response/","title":"The RFC-defined response"},{"location":"methods/","text":"When developing RESTful APIs, keep in mind and follow the various methods at your disposal. This is commonly referred to as CRUD. These stand for: Create Retrieve/Read Update Delete/Destroy use POST for Create operations Use POST APIs to create new subordinate resources, e.g. a file is subordinate to a directory containing it or a row is subordinate to a database table. Talking strictly in terms of REST, POST methods are used to create a new resource into the collection of resources. Ideally, if a resource has been created on the origin server, the response SHOULD be HTTP response code 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header. Many times, the action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either HTTP response code 200 (OK) or 204 (No Content) is the appropriate response status. Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. Please note that POST is neither safe nor idempotent and invoking two identical POST requests will result in two different resources containing the same information (except resource ids). use GET for Retrieve operations Use GET requests to retrieve resource representation/information only \u2013 and not to modify it in any way. As GET requests do not change the state of the resource, these are said to be safe methods. Additionally, GET APIs should be idempotent, which means that making multiple identical requests must produce the same result every time until another API (POST or PUT) has changed the state of the resource on the server. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process. For any given HTTP GET API, if the resource is found on the server then it must return HTTP response code 200 (OK) \u2013 along with response body which is usually either XML or JSON content (due to their platform independent nature). In case resource is NOT found on server then it must return HTTP response code 404 (NOT FOUND). Similarly, if it is determined that GET request itself is not correctly formed then server will return HTTP response code 400 (BAD REQUEST). use PUT for Update operations Use PUT APIs primarily to update existing resource (if the resource does not exist then API may decide to create a new resource or not). If a new resource has been created by the PUT API, the origin server MUST inform the user agent via the HTTP response code 201 (Created) response and if an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. The difference between the POST and PUT APIs can be observed in request URIs. POST requests are made on resource collections whereas PUT requests are made on an individual resource. PATCH Method not used The PATCH method, which is normally used for partial updates, is not used at this time for API development use DELETE for Delete operations As the name applies, DELETE APIs are used to delete resources (identified by the Request-URI). A successful response of DELETE requests SHOULD be HTTP response code 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has been queued, or 204 (No Content) if the action has been performed but the response does not include an entity. DELETE operations are idempotent. If you DELETE a resource, it\u2019s removed from the collection of resource. Repeatedly calling DELETE API on that resource will not change the outcome \u2013 however calling DELETE on a resource a second time will return a 404 (NOT FOUND) since it was already removed. Some may argue that it makes DELETE method non-idempotent. It\u2019s a matter of discussion and personal opinion. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.","title":"Methods"},{"location":"methods/#use-post-for-create-operations","text":"Use POST APIs to create new subordinate resources, e.g. a file is subordinate to a directory containing it or a row is subordinate to a database table. Talking strictly in terms of REST, POST methods are used to create a new resource into the collection of resources. Ideally, if a resource has been created on the origin server, the response SHOULD be HTTP response code 201 (Created) and contain an entity which describes the status of the request and refers to the new resource, and a Location header. Many times, the action performed by the POST method might not result in a resource that can be identified by a URI. In this case, either HTTP response code 200 (OK) or 204 (No Content) is the appropriate response status. Responses to this method are not cacheable, unless the response includes appropriate Cache-Control or Expires header fields. Please note that POST is neither safe nor idempotent and invoking two identical POST requests will result in two different resources containing the same information (except resource ids).","title":"use POST for Create operations"},{"location":"methods/#use-get-for-retrieve-operations","text":"Use GET requests to retrieve resource representation/information only \u2013 and not to modify it in any way. As GET requests do not change the state of the resource, these are said to be safe methods. Additionally, GET APIs should be idempotent, which means that making multiple identical requests must produce the same result every time until another API (POST or PUT) has changed the state of the resource on the server. If the Request-URI refers to a data-producing process, it is the produced data which shall be returned as the entity in the response and not the source text of the process, unless that text happens to be the output of the process. For any given HTTP GET API, if the resource is found on the server then it must return HTTP response code 200 (OK) \u2013 along with response body which is usually either XML or JSON content (due to their platform independent nature). In case resource is NOT found on server then it must return HTTP response code 404 (NOT FOUND). Similarly, if it is determined that GET request itself is not correctly formed then server will return HTTP response code 400 (BAD REQUEST).","title":"use GET for Retrieve operations"},{"location":"methods/#use-put-for-update-operations","text":"Use PUT APIs primarily to update existing resource (if the resource does not exist then API may decide to create a new resource or not). If a new resource has been created by the PUT API, the origin server MUST inform the user agent via the HTTP response code 201 (Created) response and if an existing resource is modified, either the 200 (OK) or 204 (No Content) response codes SHOULD be sent to indicate successful completion of the request. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable. The difference between the POST and PUT APIs can be observed in request URIs. POST requests are made on resource collections whereas PUT requests are made on an individual resource. PATCH Method not used The PATCH method, which is normally used for partial updates, is not used at this time for API development","title":"use PUT for Update operations"},{"location":"methods/#use-delete-for-delete-operations","text":"As the name applies, DELETE APIs are used to delete resources (identified by the Request-URI). A successful response of DELETE requests SHOULD be HTTP response code 200 (OK) if the response includes an entity describing the status, 202 (Accepted) if the action has been queued, or 204 (No Content) if the action has been performed but the response does not include an entity. DELETE operations are idempotent. If you DELETE a resource, it\u2019s removed from the collection of resource. Repeatedly calling DELETE API on that resource will not change the outcome \u2013 however calling DELETE on a resource a second time will return a 404 (NOT FOUND) since it was already removed. Some may argue that it makes DELETE method non-idempotent. It\u2019s a matter of discussion and personal opinion. If the request passes through a cache and the Request-URI identifies one or more currently cached entities, those entries SHOULD be treated as stale. Responses to this method are not cacheable.","title":"use DELETE for Delete operations"},{"location":"newcollection/","text":"How to add a new route Suppose you want to add the route: /api/v1/collections with the verb GET : Go to app/Config/routes.php (section \"API routing\") Add the following Example ?php Router :: connect ( { $apiPrefix } /collections , array ( controller = ApiCollection , action = view , [method] = GET ), $apiOptions ); Add an ApiCollectionController at app/Api/Version/V1/Controller/ with a public method view. This controller should extends \\Api\\Controller\\ApiController Note that, in this example, we define a route for the Api Version 1. We cover the way to handle different versions at Versioning section. Payload There are more than one way to get the incoming data (from a controller who extends \\Api\\Controller\\ApiController): $this- passedArgs Array with parameters coming directly from the route $this- getPayload() Method to get an array with all the parameters (both from the route and from the request body) $this- request- header('headerField') Method to get header values from the request The parameters coming as part of the request body are decoded based on the ContentType header value (part of the request). At the moment we support Json. Adding new Decoders for the Request Body To add a new decoder for the request body: Create a new file at app/Api/Request/ who extends the abstract class \\Api\\Request\\Request Add the new type to \\Api\\Request\\Manager::getRequestObject() (Ideally we should avoid this step in order to apply the Open-Close principle) Output The way to output the response (from any Api Controller): $this- setOutputStatusCode($statusCode) Set the Response Code (200, 201, 400, ...) $this- setOutputData($data) Set the response data There are no Views for the API. The method afterFiler (\\Api\\Controller\\ApiController) outputs what you previously set and exits. All the data is formatted based on the Accept header from the request. At the moment we only support Json. Adding new Encoders for the Output To add a new encoder for the response body: Create a new file at app/Api/Response/ who extends the abstract class \\Api\\Response\\Response Add the new type to \\Api\\Response\\Manager::getResponseObject() (Ideally we should avoid this step in order to apply the Open-Close principle)","title":"New Endpoints"},{"location":"newcollection/#how-to-add-a-new-route","text":"Suppose you want to add the route: /api/v1/collections with the verb GET : Go to app/Config/routes.php (section \"API routing\") Add the following Example ?php Router :: connect ( { $apiPrefix } /collections , array ( controller = ApiCollection , action = view , [method] = GET ), $apiOptions ); Add an ApiCollectionController at app/Api/Version/V1/Controller/ with a public method view. This controller should extends \\Api\\Controller\\ApiController Note that, in this example, we define a route for the Api Version 1. We cover the way to handle different versions at Versioning section.","title":"How to add a new route"},{"location":"newcollection/#payload","text":"There are more than one way to get the incoming data (from a controller who extends \\Api\\Controller\\ApiController): $this- passedArgs Array with parameters coming directly from the route $this- getPayload() Method to get an array with all the parameters (both from the route and from the request body) $this- request- header('headerField') Method to get header values from the request The parameters coming as part of the request body are decoded based on the ContentType header value (part of the request). At the moment we support Json.","title":"Payload"},{"location":"newcollection/#adding-new-decoders-for-the-request-body","text":"To add a new decoder for the request body: Create a new file at app/Api/Request/ who extends the abstract class \\Api\\Request\\Request Add the new type to \\Api\\Request\\Manager::getRequestObject() (Ideally we should avoid this step in order to apply the Open-Close principle)","title":"Adding new Decoders for the Request Body"},{"location":"newcollection/#output","text":"The way to output the response (from any Api Controller): $this- setOutputStatusCode($statusCode) Set the Response Code (200, 201, 400, ...) $this- setOutputData($data) Set the response data There are no Views for the API. The method afterFiler (\\Api\\Controller\\ApiController) outputs what you previously set and exits. All the data is formatted based on the Accept header from the request. At the moment we only support Json.","title":"Output"},{"location":"newcollection/#adding-new-encoders-for-the-output","text":"To add a new encoder for the response body: Create a new file at app/Api/Response/ who extends the abstract class \\Api\\Response\\Response Add the new type to \\Api\\Response\\Manager::getResponseObject() (Ideally we should avoid this step in order to apply the Open-Close principle)","title":"Adding new Encoders for the Output"},{"location":"queries/","text":"Searching, sorting, filtering and pagination are simply the result of a query on one dataset. There should be no new set of APIs to handle these actions. To achieve this, we need to append the query params with the GET method API. Let\u2019s understand with few examples how to implement these actions. Operation Types Sorting In case, the client wants to get the sorted list of companies, the GET /companies endpoint should accept multiple sort params in the query. E.g GET /companies?sort=rank_asc would sort the companies by its rank in ascending order. Filtering For filtering the dataset, we can pass various options through query params. E.g GET /companies?category=banking location=india would filter the companies list data with the company category of Banking and where the location is India. Searching When searching the company name in companies list the API endpoint should be GET /companies?search=Digital Mckinsey Pagination When the dataset is too large, we divide the data set into smaller chunks, which helps in improving the performance and is easier to handle the response. Eg. GET /companies?page=23 means get the list of companies on 23 rd page. Output and Meta sections All output shall be returned in JSON:API format Whenever an endpoint allows for optional and complex parameters, you need to include a meta section in the JSON response of the API. Meta section include items like: top limit offset total If using this parameters, use ALL of these parameters, for consistency purposes. Here's an example of a proper meta section within a resonse below: Sample Meta structure { meta : { top : false , limit : 25 , offset : 0 , total : 6608 }, data : [ { ... } ] } Important Please note that if your API does NOT use optional and complex parameters it should NOT return a meta section.","title":"Optional Parameter Queries"},{"location":"queries/#operation-types","text":"","title":"Operation Types"},{"location":"queries/#sorting","text":"In case, the client wants to get the sorted list of companies, the GET /companies endpoint should accept multiple sort params in the query. E.g GET /companies?sort=rank_asc would sort the companies by its rank in ascending order.","title":"Sorting"},{"location":"queries/#filtering","text":"For filtering the dataset, we can pass various options through query params. E.g GET /companies?category=banking location=india would filter the companies list data with the company category of Banking and where the location is India.","title":"Filtering"},{"location":"queries/#searching","text":"When searching the company name in companies list the API endpoint should be GET /companies?search=Digital Mckinsey","title":"Searching"},{"location":"queries/#pagination","text":"When the dataset is too large, we divide the data set into smaller chunks, which helps in improving the performance and is easier to handle the response. Eg. GET /companies?page=23 means get the list of companies on 23 rd page.","title":"Pagination"},{"location":"queries/#output-and-meta-sections","text":"All output shall be returned in JSON:API format Whenever an endpoint allows for optional and complex parameters, you need to include a meta section in the JSON response of the API. Meta section include items like: top limit offset total If using this parameters, use ALL of these parameters, for consistency purposes. Here's an example of a proper meta section within a resonse below: Sample Meta structure { meta : { top : false , limit : 25 , offset : 0 , total : 6608 }, data : [ { ... } ] } Important Please note that if your API does NOT use optional and complex parameters it should NOT return a meta section.","title":"Output and Meta sections"},{"location":"rules/","text":"The following items are consolidated from multiple contributing sources and are widely considered \"Best Practice\" methods when it comes to REST APIs Summary Use Plural Nouns for Collections and Sub-collections 2 URLS per resource Use NOUNS instead of Verbs for Resources Wrap the ACTUAL data in a data Field Use the Correct HTTP Status Codes Provide Descriptive Error Messages, no contractions CamelCase for Attributes Meta Data section at TOP of responses Namespaces URL Access Use Plural Nouns for Collections and Sub-collections Collections normally have many resources within them. As such, you should refer to them in the PLURAL sense, such as /assets not /asset Good Collection Name example /divisions /divisions/1 /divisions/1/assets Poor Collection Name example /division /division/1 /division/1/asset 2 URLS per resource Use 1 URL for the collection itself, and 1 URL for a single resource within that collection Example //URL that represents a collection of resources GET / api / v1 / divisions //URL that represents a single resource GET / api / v1 / divisions / 5 Use NOUNS instead of Verbs for Resources Keeps the number of URLs low and much simpler. For instance, if you needed to delete all assets in a folder, you might do something like: DELETE /folders/1/assets and not GET /folders/1/deleteAllFolderAssets Good Resource Name example GET /api/v1/divisions - Get all divisions DELETE /api/v1/folders - Delete all folders POST /api/v1/assets - Create a new asset Bad Resource Name example GET /api/v1/getAllDivisions GET /api/v1/deleteAllFolders POST /api/v1/createAsset Wrap the ACTUAL data in a data Field When returning an object or a list of objects, the actual data for the resource should be encapsulated within a data field, because this gives us: Additional space left to add metadata fields, such as pagination, links, deprecation warnings, error messages, etc Consistency across all resources and collections Compatible with the JSON:API Standard at https://jsonapi.org/ Example // GET /api/v 1 /users/ 2 response { data : { id : 2 , first_name : Janet , last_name : Weaver , avatar : https://s3.amazonaws.com/uifaces/faces/twitter/josephstein/128.jpg } } Use the Correct HTTP Status Codes More often than not, developers just return a HTTP 200 Success when the API call works, and a HTTP 400 Error when the request fails. While technically correct, they do not offer insight as to why the request failed and leads to longer debugging times and effort. It is generally accepted universally to keep the set of status codes small but providing the correct response allows developers to follow the process easier. Please refer to the HTTP Status Codes section for example. Provide Descriptive Error Messages, no contractions This one goes with the rule above, as you should provide a useful and VERBOSE description of the error Verbose Message example // example of a 400 Bad Request { errors : [ { status : 400 , message : Invalid state. Valid values are internal or external } ] } Please also note that you SHOULD NOT use contractions, like can't or couldn't , within an error message CamelCase for Attributes Use CamelCase for your attributes identifiers, starting with lowercase, such as { yearOfBirth : 1982 } Don\u2019t use underscores (year_of_birth) or capitalize (YearOfBirth). Often your RESTful web service will be consumed by a client written in JavaScript. Typically the client will convert the JSON response to a JavaScript object (by calling var person = JSON.parse(response) ) and call its attributes. Therefore, it\u2019s a good idea to stick to the JavaScript convention which makes the JavaScript code more readable and intuitive. Good example of Attributes CamelCase conventions // Do person.yearOfBirth Bad example of Attributes CamelCase conventions // Don't person.year_of_birth // violates JavaScript convention person.YearOfBirth // suggests constructor method Meta Data section at TOP of responses Whenever optional query parameters are included in an API, a META section is required in the response output. The correct place for this is BEFORE any data structures. This better allows for pagination to be handled better as well as following the JSON:API Standard at https://jsonapi.org/ . Sample Meta section response { meta : { offset : 20 , limit : 10 , total : 3465 , }, data : [ { id : 10 , dateCreated : 1504224000000 } ], links : { next : http://www.domain.com/employees?pageSize=100 continue=1504224000000_10 } } Namespaces The namespace for the API is \\Api The namespace for the API controllers is \\Api\\Controller The namespace for the API Exceptions is \\Api\\Exception URL access The defined URL structure for accessing the API is the following: Share API URL Module Base URI : {environment}-{client}-{module}.creativedrive.com QA: https://qa-walmart-share.creativedrive.com Production: https://walmart-share.creativedrive.com (Production API does NOT contain an environment tag) Module Base Path : /api/v1 Auth API URL Auth Base URI : {environment}-my-api.creativedrive.com QA: https://qa-my-api.creativedrive.com Production: https://my-api.creativedrive.com (Production API does NOT contain an environment tag) Auth Base Path : /v1/api","title":"General API Rules"},{"location":"rules/#summary","text":"Use Plural Nouns for Collections and Sub-collections 2 URLS per resource Use NOUNS instead of Verbs for Resources Wrap the ACTUAL data in a data Field Use the Correct HTTP Status Codes Provide Descriptive Error Messages, no contractions CamelCase for Attributes Meta Data section at TOP of responses Namespaces URL Access","title":"Summary"},{"location":"rules/#use-plural-nouns-for-collections-and-sub-collections","text":"Collections normally have many resources within them. As such, you should refer to them in the PLURAL sense, such as /assets not /asset Good Collection Name example /divisions /divisions/1 /divisions/1/assets Poor Collection Name example /division /division/1 /division/1/asset","title":"Use Plural Nouns for Collections and Sub-collections"},{"location":"rules/#2-urls-per-resource","text":"Use 1 URL for the collection itself, and 1 URL for a single resource within that collection Example //URL that represents a collection of resources GET / api / v1 / divisions //URL that represents a single resource GET / api / v1 / divisions / 5","title":"2 URLS per resource"},{"location":"rules/#use-nouns-instead-of-verbs-for-resources","text":"Keeps the number of URLs low and much simpler. For instance, if you needed to delete all assets in a folder, you might do something like: DELETE /folders/1/assets and not GET /folders/1/deleteAllFolderAssets Good Resource Name example GET /api/v1/divisions - Get all divisions DELETE /api/v1/folders - Delete all folders POST /api/v1/assets - Create a new asset Bad Resource Name example GET /api/v1/getAllDivisions GET /api/v1/deleteAllFolders POST /api/v1/createAsset","title":"Use NOUNS instead of Verbs for Resources"},{"location":"rules/#wrap-the-actual-data-in-a-data-field","text":"When returning an object or a list of objects, the actual data for the resource should be encapsulated within a data field, because this gives us: Additional space left to add metadata fields, such as pagination, links, deprecation warnings, error messages, etc Consistency across all resources and collections Compatible with the JSON:API Standard at https://jsonapi.org/ Example // GET /api/v 1 /users/ 2 response { data : { id : 2 , first_name : Janet , last_name : Weaver , avatar : https://s3.amazonaws.com/uifaces/faces/twitter/josephstein/128.jpg } }","title":"Wrap the ACTUAL data in a data Field"},{"location":"rules/#use-the-correct-http-status-codes","text":"More often than not, developers just return a HTTP 200 Success when the API call works, and a HTTP 400 Error when the request fails. While technically correct, they do not offer insight as to why the request failed and leads to longer debugging times and effort. It is generally accepted universally to keep the set of status codes small but providing the correct response allows developers to follow the process easier. Please refer to the HTTP Status Codes section for example.","title":"Use the Correct HTTP Status Codes"},{"location":"rules/#provide-descriptive-error-messages-no-contractions","text":"This one goes with the rule above, as you should provide a useful and VERBOSE description of the error Verbose Message example // example of a 400 Bad Request { errors : [ { status : 400 , message : Invalid state. Valid values are internal or external } ] } Please also note that you SHOULD NOT use contractions, like can't or couldn't , within an error message","title":"Provide Descriptive Error Messages, no contractions"},{"location":"rules/#camelcase-for-attributes","text":"Use CamelCase for your attributes identifiers, starting with lowercase, such as { yearOfBirth : 1982 } Don\u2019t use underscores (year_of_birth) or capitalize (YearOfBirth). Often your RESTful web service will be consumed by a client written in JavaScript. Typically the client will convert the JSON response to a JavaScript object (by calling var person = JSON.parse(response) ) and call its attributes. Therefore, it\u2019s a good idea to stick to the JavaScript convention which makes the JavaScript code more readable and intuitive. Good example of Attributes CamelCase conventions // Do person.yearOfBirth Bad example of Attributes CamelCase conventions // Don't person.year_of_birth // violates JavaScript convention person.YearOfBirth // suggests constructor method","title":"CamelCase for Attributes"},{"location":"rules/#meta-data-section-at-top-of-responses","text":"Whenever optional query parameters are included in an API, a META section is required in the response output. The correct place for this is BEFORE any data structures. This better allows for pagination to be handled better as well as following the JSON:API Standard at https://jsonapi.org/ . Sample Meta section response { meta : { offset : 20 , limit : 10 , total : 3465 , }, data : [ { id : 10 , dateCreated : 1504224000000 } ], links : { next : http://www.domain.com/employees?pageSize=100 continue=1504224000000_10 } }","title":"Meta Data section at TOP of responses"},{"location":"rules/#namespaces","text":"The namespace for the API is \\Api The namespace for the API controllers is \\Api\\Controller The namespace for the API Exceptions is \\Api\\Exception","title":"Namespaces"},{"location":"rules/#url-access","text":"The defined URL structure for accessing the API is the following: Share API URL Module Base URI : {environment}-{client}-{module}.creativedrive.com QA: https://qa-walmart-share.creativedrive.com Production: https://walmart-share.creativedrive.com (Production API does NOT contain an environment tag) Module Base Path : /api/v1 Auth API URL Auth Base URI : {environment}-my-api.creativedrive.com QA: https://qa-my-api.creativedrive.com Production: https://my-api.creativedrive.com (Production API does NOT contain an environment tag) Auth Base Path : /v1/api","title":"URL access"},{"location":"statuscodes/","text":"The RESTful Web Service should respond to a client\u2019s request with a suitable HTTP status response code. API Success Codes 2xx: Success Information 200 OK Standard response for successful HTTP requests. 201 Created The request has been fulfilled, resulting in the creation of a new resource. Use this when creating new resources. 202 Accepted The request has been accepted for processing, but the processing has not been completed. 204 No Content The server successfully finished processing the request and is not returning any content. API Failure Codes 4xx: Client Error Information 400 Bad Request The server cannot or will not process the request due to an apparent client error (e.g. malformed request, size too large, etc) 401 Unauthorized Similar to 403 Forbidden, but specifically for use when authentication has failed or has not yet been provided. 403 Forbidden The request was valid, but the server is refusing action. The user does not have the necessary permissions for a resource. 404 Not Found The requested resource could not be found but may be available in the future (e.g. getting all the assets of a user but they haven't uploaded any yet) Server Failure Codes 5xx: Server Error Information 500 Internal Server Error A generic error message, given when an unexpected condition was encountered and no more specific message is suitable. This should NEVER be returned for an API Request failure. This would be something more akin to the request being received, but the queue was full, and couldn't be added for processing. Do Not overuse 404 Try to be more precise. If the resource is available, but the user is not allowed to view it, return a 403 Forbidden.","title":"Status Codes"},{"location":"statuscodes/#api-success-codes","text":"2xx: Success Information 200 OK Standard response for successful HTTP requests. 201 Created The request has been fulfilled, resulting in the creation of a new resource. Use this when creating new resources. 202 Accepted The request has been accepted for processing, but the processing has not been completed. 204 No Content The server successfully finished processing the request and is not returning any content.","title":"API Success Codes"},{"location":"statuscodes/#api-failure-codes","text":"4xx: Client Error Information 400 Bad Request The server cannot or will not process the request due to an apparent client error (e.g. malformed request, size too large, etc) 401 Unauthorized Similar to 403 Forbidden, but specifically for use when authentication has failed or has not yet been provided. 403 Forbidden The request was valid, but the server is refusing action. The user does not have the necessary permissions for a resource. 404 Not Found The requested resource could not be found but may be available in the future (e.g. getting all the assets of a user but they haven't uploaded any yet)","title":"API Failure Codes"},{"location":"statuscodes/#server-failure-codes","text":"5xx: Server Error Information 500 Internal Server Error A generic error message, given when an unexpected condition was encountered and no more specific message is suitable. This should NEVER be returned for an API Request failure. This would be something more akin to the request being received, but the queue was full, and couldn't be added for processing. Do Not overuse 404 Try to be more precise. If the resource is available, but the user is not allowed to view it, return a 403 Forbidden.","title":"Server Failure Codes"},{"location":"synch_asynch/","text":"Synchronous calls Here's the accepted structure for adding a synchronous call to the Api Example: ApiFolderController- add() ?php /** * POST * Creates a new folder */ public function add () { // get the payload $payload = $this - getPayload (); // The next line tries to add a new folder. // We pass the payload to the Folder component method (add) and the validation process is done there. try { $result = $this - Folder - add ( $payload ); } catch ( \\App\\Exception\\Payload $payloadException ) { $requiredFieldsMessage = ; if ( count ( $payloadException - getMissingRequiredFields ()) 0 ) { $requiredFieldsMessage = Missing required fields: . implode ( , , $payloadException - getMissingRequiredFields ()); } throw new \\Api\\Exception\\ApiPayloadException ( Payload error. . $requiredFieldsMessage ); } // set the data to output as the data returned by the folder add() operation $this - setOutputStatusCode ( \\Api\\Response\\Response :: RESPONSE_CODE_CREATED ); $this - setOutputData ( $result - getData ()[ TsFolder ]); } Asynchronous calls There are some actions that start a long process and the app is unable to return the output data at the moment of the call. For these cases the API follows the next steps: Receives the request Starts the associated process Creates a unique id and associate it with the request Returns a 202 code (Accepted) Returns a Location field (as part of the headers) with a unique url to get the status of the call. Example: /api/v1.2/queue/577e6da072180 Accessing the Queue Information Accessing the API with the url provided in the Location header will return the status of the task and some extra fields: { data : { status : PENDING , url_origin : /api/v1.2/folders/5 , payload : { accountId : 3 , version : 1.2 , id : 5 , [method] : DELETE } }} //The field payload holds the payload used in the first call. There are three possible statuses: PENDING - (\\Api\\AsyncTask\\Manager::STATUS_PENDING) The task is already running (or enqueued). DONE - (\\Api\\AsyncTask\\Manager::STATUS_DONE) The task is done. NOT FOUND - (\\Api\\AsyncTask\\Manager::STATUS_NOT_FOUND) The app could not find the associated task. Possible reasons: it never existed or it expired (one task exists only for 5 hours within the list after its last modification) NOTE: Returning OK is not Acceptable - it must be 1 of the 3 listed above Examples of How to register and start an async task The method addAsyncCall(Callable $callback) creates an unique id for the task and calls the provided callback function. It passes two parameters to the callback: $id : The generated id $location : The api url to check the status of the task The callback function should start the process. Example ?php public function action () { $self = $this ; $this - addAsyncCall ( function ( $queueId , $url ) use ( $self ){ // $queueId = the unique id associated to this task $payload = $self - getPayload (); // here you should start the long process ... }); } How to modify a previously registered async task status To modify a previously registered task, simply follow this example: Example ?php public function action () { $this - getAsyncTaskManager () - modify ( $id , $status , $url ); } Redirects Once you modify the status to DONE you could provide a final url in order to redirect the user to get the final data related to the finished task. Then, the next time the user asks for this id it is going to be automatically redirected to the provided url (using a 303 HTTP code and a Location header).","title":"Synchronous & Asynchronous Calls"},{"location":"synch_asynch/#synchronous-calls","text":"Here's the accepted structure for adding a synchronous call to the Api Example: ApiFolderController- add() ?php /** * POST * Creates a new folder */ public function add () { // get the payload $payload = $this - getPayload (); // The next line tries to add a new folder. // We pass the payload to the Folder component method (add) and the validation process is done there. try { $result = $this - Folder - add ( $payload ); } catch ( \\App\\Exception\\Payload $payloadException ) { $requiredFieldsMessage = ; if ( count ( $payloadException - getMissingRequiredFields ()) 0 ) { $requiredFieldsMessage = Missing required fields: . implode ( , , $payloadException - getMissingRequiredFields ()); } throw new \\Api\\Exception\\ApiPayloadException ( Payload error. . $requiredFieldsMessage ); } // set the data to output as the data returned by the folder add() operation $this - setOutputStatusCode ( \\Api\\Response\\Response :: RESPONSE_CODE_CREATED ); $this - setOutputData ( $result - getData ()[ TsFolder ]); }","title":"Synchronous calls"},{"location":"synch_asynch/#asynchronous-calls","text":"There are some actions that start a long process and the app is unable to return the output data at the moment of the call. For these cases the API follows the next steps: Receives the request Starts the associated process Creates a unique id and associate it with the request Returns a 202 code (Accepted) Returns a Location field (as part of the headers) with a unique url to get the status of the call. Example: /api/v1.2/queue/577e6da072180","title":"Asynchronous calls"},{"location":"synch_asynch/#accessing-the-queue-information","text":"Accessing the API with the url provided in the Location header will return the status of the task and some extra fields: { data : { status : PENDING , url_origin : /api/v1.2/folders/5 , payload : { accountId : 3 , version : 1.2 , id : 5 , [method] : DELETE } }} //The field payload holds the payload used in the first call. There are three possible statuses: PENDING - (\\Api\\AsyncTask\\Manager::STATUS_PENDING) The task is already running (or enqueued). DONE - (\\Api\\AsyncTask\\Manager::STATUS_DONE) The task is done. NOT FOUND - (\\Api\\AsyncTask\\Manager::STATUS_NOT_FOUND) The app could not find the associated task. Possible reasons: it never existed or it expired (one task exists only for 5 hours within the list after its last modification) NOTE: Returning OK is not Acceptable - it must be 1 of the 3 listed above","title":"Accessing the Queue Information"},{"location":"synch_asynch/#examples-of-how-to-register-and-start-an-async-task","text":"The method addAsyncCall(Callable $callback) creates an unique id for the task and calls the provided callback function. It passes two parameters to the callback: $id : The generated id $location : The api url to check the status of the task The callback function should start the process. Example ?php public function action () { $self = $this ; $this - addAsyncCall ( function ( $queueId , $url ) use ( $self ){ // $queueId = the unique id associated to this task $payload = $self - getPayload (); // here you should start the long process ... }); }","title":"Examples of How to register and start an async task"},{"location":"synch_asynch/#how-to-modify-a-previously-registered-async-task-status","text":"To modify a previously registered task, simply follow this example: Example ?php public function action () { $this - getAsyncTaskManager () - modify ( $id , $status , $url ); }","title":"How to modify a previously registered async task status"},{"location":"synch_asynch/#redirects","text":"Once you modify the status to DONE you could provide a final url in order to redirect the user to get the final data related to the finished task. Then, the next time the user asks for this id it is going to be automatically redirected to the provided url (using a 303 HTTP code and a Location header).","title":"Redirects"},{"location":"terminologies/","text":"While a list of the standard REST API terminolgies can be found here: http://apiglossary.com , here's a short list of the most important ones you'll be using. Resource Resource is an object or entity that has a URI where it can be manipulated through HTTP requests. The resources has some associated data with it and there can be set of methods to operate on it. Collections Collections are set of resources grouped together. In many ways, think of collections as the table in a database. If you typed Select * from divisions you'd get all the divisions. In that same paradigm, a REST API call to GET /api/v1/divisions returns all the divisions Endpoint Endpoint is the URI that goes after the base URL and points towards the requested API functionality. Method Method is the part of an HTTP request that tells the server what the client wants to do. E.g. GET, POST, PUT, DELETE, PATCH Status Code Status Code is the HTTP status codes are what the server sends in the response back to the client with regards to the status of the request.","title":"Terminologies"},{"location":"versioning/","text":"Please note that this reference of API versioning is not the same as Code under Version Control. There could be multiple versions of a source file under a single API version. Version control of code is defined under the CreativeDrive Coding Standards and Guidelines; this reference is a subset and for REST APIs only (aka Multiple versions of the same application)\" API Versioning You may end up in situations where the above approaches don\u2019t work and you really have to provide different versions of your API. Versioning allows you to release incompatible and breaking changes of your API under a new version without breaking the clients. They can continue consuming the old version. The clients can migrate to the new version at their own speed. Here are the two most popular approaches for versioning: Versioning via URLs: /api/v1/ ( DEFAULT METHOD ) Versioning via the Accept HTTP Header: Accept: application/vnd.myapi.v1+json (Content Negotiation, NOT USED ) For Creative Drive, we use the Versioning via URLs , and the current BaseURL for the API is: /api/v1 . Get the requested API version From any API controller (who inherits from Api\\Controller\\ApiController) you could get the requested version: ?php public function action () { $version = $this - getApiVersion (); } Get and Set the codebase version Using the class \\Utils\\Load\\Version you can set and ask for the current codebase version. ?php // set the codebase version as 1.5 \\Utils\\Load\\Version :: setCurrentCodeVersion ( 1.5 ); // get the current version $currentVersion = \\Utils\\Load\\Version :: getCurrentCodeVersion (); The convention we use to set the current codebase version is: For incoming API calls: Set the codebase version as the requested API version. No-API calls: Set the codebase version as the latest available version. Every time the app loads a Model or a Component it will use the file associated with the current version (in case that there is more than one version for the requested entity). You do not have to ask explicitly for a particular version, the app handles it for you. Also, for every API call the app will use the controller associated with the requested version, so the models and components. If, for any reason, the app tries to load an explicit version for a Model / Component and there is no an associated file for that version, then it attempts to load the previous available version. If there is not a previous available version, it throws an Exception. Define API Versioned Controllers* There are two main steps to define a Controller to cover an Api route: Add the Controller file to app/Api/Version/Vn/Controller. The file name should be ApiResourceController.php (replace Resource by your resource name) Add an entry to app/Config/klient/default/default.json Let see an example. Suppose we need to add the version 2 for the Assets resource. Then the steps should be the following: Create the file: app/Api/Version/V2/Controller/ApiAssetsController.php Add an entry to app/Config/klient/default/default.json (versions Controller controllerName) : versions : { Controller : { ... , ApiAssets : { ... 2 : \\\\Api\\\\Version\\\\V2\\\\Controller\\\\ApiAsset } }, Component : { ... }, Model : { ... } } As we are adding a Controller for the version 2, it could be possible that there are a previous version for the same Controller (note that, in the other hand, it could be a new Controller for a new resource introduced in the version 2, so in that case there is no a previous Controller for it). Then our new Controller should inherit from the previous version Controller, in order to reuse its actions. We only rewrite the actions involved with the breaking changes related to the new version. ?php namespace Api\\Version\\V2\\Controller ; class ApiAssetsController extends \\Api\\Version\\V1\\Controller\\ApiAssetsController { ... } The new Controller must be under the namespace Api\\Version\\Vn\\Controller, where n is the version. Define Versioned Components The steps to define a versioned Component are the following: Create a new BaseComponent file: app/Api/Version/Vn/Controller/Component/BaseNewComponent.php ?php namespace Api\\Version\\Vn\\Controller\\Component ; class BaseNewComponent extends \\Api\\Version\\Vx\\Controller\\Component\\BaseNewComponent { // put the Component code here, but only the new feature // modifications for this version } NOTE: In case that exists a previous version, the Base class should inherit from the previous version Base (x n). If there is not a previous version, the Base class should inherit from \\Component: ?php namespace Api\\Version\\V1\\Controller\\Component ; class BaseNewComponent extends \\Component { // put the Component code here } Create a new Component file: app/Api/Version/Vn/Controller/Component/NewComponent.php ?php class NewComponent extends \\Api\\Version\\Vx\\Controller\\Component\\BaseNewComponent { // empty } Note that the Component should inherit from the Base created in the previous step. And the body of this file should be empty, all the code should be in the Base. The reason to put the code into the Base instead of into the Component is to allow new versions to inherit from previous version files. The Component has not a namespace (in order to follow CakePHP conventions), so every Component will have the same, no matter the version version. On the other hand, the Base has a namespace based on the version, so a new Base could explicitly inherit from an old one. Modify the original Component at the CakePHP path (app/Controller/Component/NewComponent.php) ?php /** * Loads NewComponent Component according to the current code version (\\Utils\\Load\\Version::getCurrentCodeVersion() ) * The component code is at app/Api/Version/Vn/Controller/Component/NewComponent.php */ \\Utils\\Load\\Version :: loadComponent ( NewComponent ); The purpose of the single line (above) is only the loading of the versioned Component. Yes, you can directly load the versioned Component, but we keep the file here at the CakePHP folder in order to not break the framework flow. Add an entry to app/Config/klient/default/default.json versions : { Controller : { ... }, Component : { ..., NewComponent : { n : Vn } }, Model : { ... } } Under the \"Component\" entry we added the version and the folder (app/Api/Version/n/...) where the new files are located. Define Versioned Models The steps to define a versioned Model are the following: Create a new BaseExample file: app/Api/Version/Vn/Model/BaseExample.php ?php namespace Api\\Version\\Vn\\Model ; class ExampleHelper extends \\Api\\Version\\Vx\\Model\\BaseExample { // put the Model code here, but only the new features / modifications for this version } In case that exists a previous version, the Base class should inherit from the previous version Base (x n). If there is not a previous version, the Base class should inherit from \\AppModel: ?php namespace Api\\Version\\V1\\Model ; class BaseExample extends \\AppModel { // put the Model code here } Create a new Model file: app/Api/Version/Vn/Model/Example.php ?php class Example extends \\Api\\Version\\Vx\\Model\\BaseExample { // empty } Note that the Model should inherit from the Base created in the previous step. And the body of this file should be empty, all the code should be in the Base. The reason to put the code into the Base instead of into the Model is to allow new versions to inherit from previous version files. The Model has not a namespace (in order to follow CakePHP conventions), so every Model will have the same name on different versions. On the other hand, the Base has a namespace based on the version, so a new Base could explicitly inherit from an old one. Modify the original Model at the CakePHP path (app/Model/Example.php) ?php /** * Loads Example model according to the current code version (\\Utils\\Load\\Version::getCurrentCodeVersion() ) * The model code is at app/Api/Version/V.../Model/Example.php */ \\Utils\\Load\\Version :: loadModel ( Example ); The purpose of the single line (above) is only the loading of the versioned Model. Yes, you can directly load the versioned Model, but we keep the file here at the CakePHP folder in order to not break the framework flow. Add an entry to app/Config/klient/default/default.json versions : { Controller : { ... }, Component : { ... }, Model : { ..., Example : { n : Vn } } } Under the \"Model\" entry we added the version and the folder (app/Api/Version/n/...) where the new files are located.","title":"Versioning"},{"location":"versioning/#api-versioning","text":"You may end up in situations where the above approaches don\u2019t work and you really have to provide different versions of your API. Versioning allows you to release incompatible and breaking changes of your API under a new version without breaking the clients. They can continue consuming the old version. The clients can migrate to the new version at their own speed. Here are the two most popular approaches for versioning: Versioning via URLs: /api/v1/ ( DEFAULT METHOD ) Versioning via the Accept HTTP Header: Accept: application/vnd.myapi.v1+json (Content Negotiation, NOT USED ) For Creative Drive, we use the Versioning via URLs , and the current BaseURL for the API is: /api/v1 .","title":"API Versioning"},{"location":"versioning/#get-the-requested-api-version","text":"From any API controller (who inherits from Api\\Controller\\ApiController) you could get the requested version: ?php public function action () { $version = $this - getApiVersion (); }","title":"Get the requested API version"},{"location":"versioning/#get-and-set-the-codebase-version","text":"Using the class \\Utils\\Load\\Version you can set and ask for the current codebase version. ?php // set the codebase version as 1.5 \\Utils\\Load\\Version :: setCurrentCodeVersion ( 1.5 ); // get the current version $currentVersion = \\Utils\\Load\\Version :: getCurrentCodeVersion (); The convention we use to set the current codebase version is: For incoming API calls: Set the codebase version as the requested API version. No-API calls: Set the codebase version as the latest available version. Every time the app loads a Model or a Component it will use the file associated with the current version (in case that there is more than one version for the requested entity). You do not have to ask explicitly for a particular version, the app handles it for you. Also, for every API call the app will use the controller associated with the requested version, so the models and components. If, for any reason, the app tries to load an explicit version for a Model / Component and there is no an associated file for that version, then it attempts to load the previous available version. If there is not a previous available version, it throws an Exception.","title":"Get and Set the codebase version"},{"location":"versioning/#define-api-versioned-controllers","text":"There are two main steps to define a Controller to cover an Api route: Add the Controller file to app/Api/Version/Vn/Controller. The file name should be ApiResourceController.php (replace Resource by your resource name) Add an entry to app/Config/klient/default/default.json Let see an example. Suppose we need to add the version 2 for the Assets resource. Then the steps should be the following: Create the file: app/Api/Version/V2/Controller/ApiAssetsController.php Add an entry to app/Config/klient/default/default.json (versions Controller controllerName) : versions : { Controller : { ... , ApiAssets : { ... 2 : \\\\Api\\\\Version\\\\V2\\\\Controller\\\\ApiAsset } }, Component : { ... }, Model : { ... } } As we are adding a Controller for the version 2, it could be possible that there are a previous version for the same Controller (note that, in the other hand, it could be a new Controller for a new resource introduced in the version 2, so in that case there is no a previous Controller for it). Then our new Controller should inherit from the previous version Controller, in order to reuse its actions. We only rewrite the actions involved with the breaking changes related to the new version. ?php namespace Api\\Version\\V2\\Controller ; class ApiAssetsController extends \\Api\\Version\\V1\\Controller\\ApiAssetsController { ... } The new Controller must be under the namespace Api\\Version\\Vn\\Controller, where n is the version.","title":"Define API Versioned Controllers*"},{"location":"versioning/#define-versioned-components","text":"The steps to define a versioned Component are the following: Create a new BaseComponent file: app/Api/Version/Vn/Controller/Component/BaseNewComponent.php ?php namespace Api\\Version\\Vn\\Controller\\Component ; class BaseNewComponent extends \\Api\\Version\\Vx\\Controller\\Component\\BaseNewComponent { // put the Component code here, but only the new feature // modifications for this version } NOTE: In case that exists a previous version, the Base class should inherit from the previous version Base (x n). If there is not a previous version, the Base class should inherit from \\Component: ?php namespace Api\\Version\\V1\\Controller\\Component ; class BaseNewComponent extends \\Component { // put the Component code here } Create a new Component file: app/Api/Version/Vn/Controller/Component/NewComponent.php ?php class NewComponent extends \\Api\\Version\\Vx\\Controller\\Component\\BaseNewComponent { // empty } Note that the Component should inherit from the Base created in the previous step. And the body of this file should be empty, all the code should be in the Base. The reason to put the code into the Base instead of into the Component is to allow new versions to inherit from previous version files. The Component has not a namespace (in order to follow CakePHP conventions), so every Component will have the same, no matter the version version. On the other hand, the Base has a namespace based on the version, so a new Base could explicitly inherit from an old one. Modify the original Component at the CakePHP path (app/Controller/Component/NewComponent.php) ?php /** * Loads NewComponent Component according to the current code version (\\Utils\\Load\\Version::getCurrentCodeVersion() ) * The component code is at app/Api/Version/Vn/Controller/Component/NewComponent.php */ \\Utils\\Load\\Version :: loadComponent ( NewComponent ); The purpose of the single line (above) is only the loading of the versioned Component. Yes, you can directly load the versioned Component, but we keep the file here at the CakePHP folder in order to not break the framework flow. Add an entry to app/Config/klient/default/default.json versions : { Controller : { ... }, Component : { ..., NewComponent : { n : Vn } }, Model : { ... } } Under the \"Component\" entry we added the version and the folder (app/Api/Version/n/...) where the new files are located.","title":"Define Versioned Components"},{"location":"versioning/#define-versioned-models","text":"The steps to define a versioned Model are the following: Create a new BaseExample file: app/Api/Version/Vn/Model/BaseExample.php ?php namespace Api\\Version\\Vn\\Model ; class ExampleHelper extends \\Api\\Version\\Vx\\Model\\BaseExample { // put the Model code here, but only the new features / modifications for this version } In case that exists a previous version, the Base class should inherit from the previous version Base (x n). If there is not a previous version, the Base class should inherit from \\AppModel: ?php namespace Api\\Version\\V1\\Model ; class BaseExample extends \\AppModel { // put the Model code here } Create a new Model file: app/Api/Version/Vn/Model/Example.php ?php class Example extends \\Api\\Version\\Vx\\Model\\BaseExample { // empty } Note that the Model should inherit from the Base created in the previous step. And the body of this file should be empty, all the code should be in the Base. The reason to put the code into the Base instead of into the Model is to allow new versions to inherit from previous version files. The Model has not a namespace (in order to follow CakePHP conventions), so every Model will have the same name on different versions. On the other hand, the Base has a namespace based on the version, so a new Base could explicitly inherit from an old one. Modify the original Model at the CakePHP path (app/Model/Example.php) ?php /** * Loads Example model according to the current code version (\\Utils\\Load\\Version::getCurrentCodeVersion() ) * The model code is at app/Api/Version/V.../Model/Example.php */ \\Utils\\Load\\Version :: loadModel ( Example ); The purpose of the single line (above) is only the loading of the versioned Model. Yes, you can directly load the versioned Model, but we keep the file here at the CakePHP folder in order to not break the framework flow. Add an entry to app/Config/klient/default/default.json versions : { Controller : { ... }, Component : { ... }, Model : { ..., Example : { n : Vn } } } Under the \"Model\" entry we added the version and the folder (app/Api/Version/n/...) where the new files are located.","title":"Define Versioned Models"}]}