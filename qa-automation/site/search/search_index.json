{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The goal of these guidelines is to create uniform coding habits among software personnel in the engineering department so that reading, checking, and maintaining code written by different persons becomes easier. The intent of these standards is to define a natural style and consistency, yet leave to the authors of the engineering department source code, the freedom to practice their craft without unnecessary burden. When a project adheres to common standards many good things happen: Programmers can go into any code and figure out what\u2019s going on, so maintainability, readability, and reusability are increased. Code walk throughs become less painful. New people can get up to speed quickly. People new to a language are spared the need to develop a personal style and defend it to death. People new to a language are spared making the same mistakes over and over again, so reliability is increased. People make fewer mistakes in consistent environments. Idiosyncratic styles and college-learned behaviors are replaced with an emphasis on business concerns - high productivity, maintainability, shared authorship, etc. Experience over many projects points to the conclusion that coding standards help the project to run smoothly. They aren\u2019t necessary for success, but they help. Most arguments against a particular standard come from the ego. Few decisions in a reasonable standard really can be said to be technically deficient, just matters of taste. So, in the interests of establishing the engineering department as a showcase software development environment, be flexible, control the ego a bit, and remember any project is a team effort. It\u2019s important to apply a consistent coding style across a project. When maintaining code, it\u2019s better to conform to the style of the existing code rather than blindly follow this document or your own coding style. Since a very large portion of project scope is after-delivery maintenance or enhancement, coding standards reduce the cost of a project by easing the learning or re-learning task when code needs to be addressed by people other than the author, or by the author after a long absence. Coding standards help ensure that the author need not be present for the maintenance and enhancement phase.","title":"Introduction"},{"location":"asynch_op_handling/","text":"","title":"Asynch op handling"},{"location":"before_after_usage/","text":"","title":"Before after usage"},{"location":"categories_criticality/","text":"Categories Test suites which contain a large number of individual tests can (and should) be additionally classified with a test category. Test suites can be defined and executed from a profile definition. Special Note: Automation tests can have multiple categories attached to them in the categories section. Automation tests that have multiple categories will only be run once when a profile is invoked Additional information from Apache detailing the use of categories can be found here: http://maven.apache.org/surefire/maven-surefire-plugin/examples/junit.html An example of how a category is defined within a test is provided: @Test @Category({Basic.class}) public void DownloadMultiAssetViewTiffsFromGlobal() throws Exception { ... } Within the POM, a profile can be specified as thus: profiles profile id AllTestsWithoutCollections /id build plugins plugin groupId org.apache.maven.plugins /groupId artifactId maven-surefire-plugin /artifactId version ${maven-surefire-plugin.version} /version configuration groups com.creativedrive.categories.Basic, com.creativedrive.categories.Search, com.creativedrive.categories.Bug /groups /configuration /plugin /plugins /build /profile /profiles Then tests specific to that profile can be invoked: mvn clean test -PAllTestsWithoutCollections NOTE: if a profile is invoked, all category classes defined within the 'configuration.groups' section will be invoked Criticality It is important to label tests with how critical the issue is. Test criticality is usually defined in the JIRA priority section of the corresponding bug or story ticket. Priority levels are defined as (in order of hightest to lowest): HotFix Critical Major Minor Trivial","title":"Test categories and criticality"},{"location":"categories_criticality/#categories","text":"Test suites which contain a large number of individual tests can (and should) be additionally classified with a test category. Test suites can be defined and executed from a profile definition. Special Note: Automation tests can have multiple categories attached to them in the categories section. Automation tests that have multiple categories will only be run once when a profile is invoked Additional information from Apache detailing the use of categories can be found here: http://maven.apache.org/surefire/maven-surefire-plugin/examples/junit.html An example of how a category is defined within a test is provided: @Test @Category({Basic.class}) public void DownloadMultiAssetViewTiffsFromGlobal() throws Exception { ... } Within the POM, a profile can be specified as thus: profiles profile id AllTestsWithoutCollections /id build plugins plugin groupId org.apache.maven.plugins /groupId artifactId maven-surefire-plugin /artifactId version ${maven-surefire-plugin.version} /version configuration groups com.creativedrive.categories.Basic, com.creativedrive.categories.Search, com.creativedrive.categories.Bug /groups /configuration /plugin /plugins /build /profile /profiles Then tests specific to that profile can be invoked: mvn clean test -PAllTestsWithoutCollections NOTE: if a profile is invoked, all category classes defined within the 'configuration.groups' section will be invoked","title":"Categories"},{"location":"categories_criticality/#criticality","text":"It is important to label tests with how critical the issue is. Test criticality is usually defined in the JIRA priority section of the corresponding bug or story ticket. Priority levels are defined as (in order of hightest to lowest): HotFix Critical Major Minor Trivial","title":"Criticality"},{"location":"dev_environment/","text":"The QA team will develop both UI and RestAPI automation code using general software coding standards outlined herein for code written in any text based programming language such as, but not limited to, the Java software language. The Project management tool to be used for QA Automation Code development will be a Maven Framework, and discussed in detail below. Tools The following are a list of tools used during the development process for automation code. Maven IDE (Eclipse, IntelliJ, etc.) Jenkins optional : Homebrew Maven Overview Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. Maven is part of the Apache Maven Project . Objectives Maven\u2019s primary goal is to allow a developer to comprehend the complete state of a development effort in the shortest period of time. In order to attain this goal there are several areas of concern that Maven attempts to deal with: Making the build process easy Providing a uniform build system Providing quality project information Providing guidelines for best practices development Allowing transparent migration to new features IDE An integrated development environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of a source code editor, build automation tools, and a debugger. Most modern IDEs have intelligent code completion. Some IDEs, such as NetBeans and Eclipse, contain a compiler, interpreter, or both Jenkins Jenkins is an open source automation server written in Java. Jenkins helps to automate the non-human part of the software development process, with continuous integration and facilitating technical aspects of continuous delivery. It is a server-based system that runs in servlet containers such as Apache Tomcat. It supports version control tools, including AccuRev, CVS, Subversion, Git, Mercurial, Perforce, ClearCase and RTC, and can execute Apache Ant, Apache Maven and sbt based projects as well as arbitrary shell scripts and Windows batch commands. Builds can be triggered by various means, for example by commit in a version control system, by scheduling via a cron-like mechanism and by requesting a specific build URL. It can also be triggered after the other builds in the queue have completed. Jenkins functionality can be extended with plugins. Since java is native to Jenkins, writing automation code in Java allows for a seemless integration for automated build deployments without the need for an additional compiler. Homebrew Homebrew is a free and open-source software package management system that simplifies the installation of software on Apple's macOS operating system.","title":"Development Environment and Tools"},{"location":"dev_environment/#tools","text":"The following are a list of tools used during the development process for automation code. Maven IDE (Eclipse, IntelliJ, etc.) Jenkins optional : Homebrew","title":"Tools"},{"location":"dev_environment/#maven","text":"","title":"Maven"},{"location":"dev_environment/#overview","text":"Maven is a software project management and comprehension tool. Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation from a central piece of information. Maven is part of the Apache Maven Project .","title":"Overview"},{"location":"dev_environment/#objectives","text":"Maven\u2019s primary goal is to allow a developer to comprehend the complete state of a development effort in the shortest period of time. In order to attain this goal there are several areas of concern that Maven attempts to deal with: Making the build process easy Providing a uniform build system Providing quality project information Providing guidelines for best practices development Allowing transparent migration to new features","title":"Objectives"},{"location":"dev_environment/#ide","text":"An integrated development environment (IDE) is a software application that provides comprehensive facilities to computer programmers for software development. An IDE normally consists of a source code editor, build automation tools, and a debugger. Most modern IDEs have intelligent code completion. Some IDEs, such as NetBeans and Eclipse, contain a compiler, interpreter, or both","title":"IDE"},{"location":"dev_environment/#jenkins","text":"Jenkins is an open source automation server written in Java. Jenkins helps to automate the non-human part of the software development process, with continuous integration and facilitating technical aspects of continuous delivery. It is a server-based system that runs in servlet containers such as Apache Tomcat. It supports version control tools, including AccuRev, CVS, Subversion, Git, Mercurial, Perforce, ClearCase and RTC, and can execute Apache Ant, Apache Maven and sbt based projects as well as arbitrary shell scripts and Windows batch commands. Builds can be triggered by various means, for example by commit in a version control system, by scheduling via a cron-like mechanism and by requesting a specific build URL. It can also be triggered after the other builds in the queue have completed. Jenkins functionality can be extended with plugins. Since java is native to Jenkins, writing automation code in Java allows for a seemless integration for automated build deployments without the need for an additional compiler.","title":"Jenkins"},{"location":"dev_environment/#homebrew","text":"Homebrew is a free and open-source software package management system that simplifies the installation of software on Apple's macOS operating system.","title":"Homebrew"},{"location":"error_handling/","text":"General Rules Functions that can fail (i.e. file I/O) should always return a success or error as a return code parameter. Any time a subroutine calls a function that returns an error condition, the error condition should be captured in a log (at a minimum) to the system console and to the log4j2 log file as well. Error recovery should be handled in the routine that is responsible for the domain in which the error occurs (e.g. A file error should not be passed up from file_IO( ) to Main for handling). The WebUtil file (package com.creativedrive.util.WebUtil) contains a 'takeAScreenshot' method that can be used during UI tests (example below:). This can be invoked during a verification routine or from a try-catch routine on failure. example.ui.takeascreenshot: public static void takeAScreenshot(String name, WebDriver driver) throws Exception { DateTimeFormatter formatter = DateTimeFormatter.ofPattern( yyyy-MM-dd HH:mm:ss ); LocalDateTime date = LocalDateTime.now(); String formattedDateTime = date.format(formatter); File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(screenshots + / + name + _ + formattedDateTime + .png )); } RestAPI test setup should have logging capabilities (ie. 'log().all()' ) turned on in both the request specification and the request response Specifications example.restapi.logging: response = RestAssured.given(). header( Content-Type , application/json ). header( Authorization , bearerToken). pathParam( defaultLocation , defaultLocation). log().all(). when(). get( /locations/{defaultLocation} ). then(). log().all(). statusCode(200). contentType( application/vnd.api+json ). extract().response();","title":"Specifications for Error Handling"},{"location":"error_handling/#general-rules","text":"Functions that can fail (i.e. file I/O) should always return a success or error as a return code parameter. Any time a subroutine calls a function that returns an error condition, the error condition should be captured in a log (at a minimum) to the system console and to the log4j2 log file as well. Error recovery should be handled in the routine that is responsible for the domain in which the error occurs (e.g. A file error should not be passed up from file_IO( ) to Main for handling). The WebUtil file (package com.creativedrive.util.WebUtil) contains a 'takeAScreenshot' method that can be used during UI tests (example below:). This can be invoked during a verification routine or from a try-catch routine on failure. example.ui.takeascreenshot: public static void takeAScreenshot(String name, WebDriver driver) throws Exception { DateTimeFormatter formatter = DateTimeFormatter.ofPattern( yyyy-MM-dd HH:mm:ss ); LocalDateTime date = LocalDateTime.now(); String formattedDateTime = date.format(formatter); File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE); FileUtils.copyFile(scrFile, new File(screenshots + / + name + _ + formattedDateTime + .png )); } RestAPI test setup should have logging capabilities (ie. 'log().all()' ) turned on in both the request specification and the request response Specifications example.restapi.logging: response = RestAssured.given(). header( Content-Type , application/json ). header( Authorization , bearerToken). pathParam( defaultLocation , defaultLocation). log().all(). when(). get( /locations/{defaultLocation} ). then(). log().all(). statusCode(200). contentType( application/vnd.api+json ). extract().response();","title":"General Rules"},{"location":"file_organization/","text":"Files used for QA automation are stored under project directories that correspond to their respective teams. Projects The automation files used for the SHARE team are located under the 'shinyshare' project. The files used for the TRACK team are located under the 'track' porject. The files used for the VIEW team are located under the 'view' project. Project Suite files Project suites are broken down by categories folders, page objects folders, utility functions, resource folders, and testsuite folders. Files that are generated, such as the .class files, during the test cycle are placed with the target directory which is used as a test artifact directory as well in Jenkins. Category files Category files are interface type java files that are very simple in design and invoked in individual tests in conjunction with running Maven Profiles. package com.shinyshare.categories; import org.junit.experimental.categories.Categories; import org.junit.runner.RunWith; @RunWith(Categories.class) @Categories.IncludeCategory(Bug.class) public interface Bug { } Page Object files A page object is a class that simply stores your page elements. Elements and methods are housed in the page object file. This pattern allows testers to write clean code, avoid duplication, and better maintain their suites. Utility Files Utility files are files that perform a function that can be used with a testsuite, but are outside the scope of an individual page or project. Functions, such as JSON file readers, random images generators, or movie creators are the type of files that are located within this directory. Resource Files Resource files are files that affect suite configuration or invoke specific drivers for different test execution. Examples of files found here are the log4j2.xml configuration file, and drivers for Linux, Windows, and Mac chromedriver executables. Testsuite Files Testsuite files are further broken down by 'RestAPI' test suites and 'Smoke' test suites. RestAPI files do not have a UI interface and test only backend and database functions. Smoke files are UI-based test which test UI functions within the scope of the project team. For instance, SHARE UI-tests invoke and validate functions with the SHARE module, such as administrative functions, uploading files, and adding/editing metadata. Target files The target directory is used to house all output of the build. Files such as surefire reports, test class files, log4j files, screenshots, and generated-test-sources are located within these directory files. Running the command mvn clean will destory all files within this directory.","title":"File Organization"},{"location":"file_organization/#projects","text":"The automation files used for the SHARE team are located under the 'shinyshare' project. The files used for the TRACK team are located under the 'track' porject. The files used for the VIEW team are located under the 'view' project.","title":"Projects"},{"location":"file_organization/#project-suite-files","text":"Project suites are broken down by categories folders, page objects folders, utility functions, resource folders, and testsuite folders. Files that are generated, such as the .class files, during the test cycle are placed with the target directory which is used as a test artifact directory as well in Jenkins.","title":"Project Suite files"},{"location":"file_organization/#category-files","text":"Category files are interface type java files that are very simple in design and invoked in individual tests in conjunction with running Maven Profiles. package com.shinyshare.categories; import org.junit.experimental.categories.Categories; import org.junit.runner.RunWith; @RunWith(Categories.class) @Categories.IncludeCategory(Bug.class) public interface Bug { }","title":"Category files"},{"location":"file_organization/#page-object-files","text":"A page object is a class that simply stores your page elements. Elements and methods are housed in the page object file. This pattern allows testers to write clean code, avoid duplication, and better maintain their suites.","title":"Page Object files"},{"location":"file_organization/#utility-files","text":"Utility files are files that perform a function that can be used with a testsuite, but are outside the scope of an individual page or project. Functions, such as JSON file readers, random images generators, or movie creators are the type of files that are located within this directory.","title":"Utility Files"},{"location":"file_organization/#resource-files","text":"Resource files are files that affect suite configuration or invoke specific drivers for different test execution. Examples of files found here are the log4j2.xml configuration file, and drivers for Linux, Windows, and Mac chromedriver executables.","title":"Resource Files"},{"location":"file_organization/#testsuite-files","text":"Testsuite files are further broken down by 'RestAPI' test suites and 'Smoke' test suites. RestAPI files do not have a UI interface and test only backend and database functions. Smoke files are UI-based test which test UI functions within the scope of the project team. For instance, SHARE UI-tests invoke and validate functions with the SHARE module, such as administrative functions, uploading files, and adding/editing metadata.","title":"Testsuite Files"},{"location":"file_organization/#target-files","text":"The target directory is used to house all output of the build. Files such as surefire reports, test class files, log4j files, screenshots, and generated-test-sources are located within these directory files. Running the command mvn clean will destory all files within this directory.","title":"Target files"},{"location":"global_indentifier/","text":"","title":"Global indentifier"},{"location":"headers/","text":"A File Header shall be placed at the beginning of each source file. The file header should include the following File name Project or package definition Brief Description of purpose of file any dependancies or special instructions For instance: /*************** * BaseSetup.java * package com.shinyshare; * * This is the base file from which all dependant libraries, configuration * utilities, and browser functions initiate from. Testing configuration * variables are defined in the setup() method, as well as the browser * definitions and window sizing. * * Special instructions: * The @After section tears down the driver if it is not NULL. * The following RULE must rename in place in order for testnames to be accessed. * - @Rule public TestName testName = new TestName(); ***************/","title":"Headers"},{"location":"libraries/","text":"Software libraries used during the test cycles are defined within the Maven pom.xml file. These libraries are located under the dependencies section of the pom. Current libraries listed in the pom include: Library Function selenium-java handles the selenium test structures and execution junit selenium test reporting and aggragation mysql adds functionality for connecting to, read from, and editing myself databases selenium remote driver allows for executes selenium tests remotely imageio-core used during the Asset Processor tests for reading image files types imageio-tiff sub-library from imageio specifically for TIFF file types imageio-psd sub-library from imageio specifically for PSD file types commons-csv used for reading, creating and editing CSV files rest-assured Rest API framework library; allows for sending REST API calls and receiving their responses json JSON file support json-schema-validator sub-library of JSON; validates schema structures mondo-java-driver adds functionality for connecting to, reading from, and editing mongo databases jedis Java REDIS connector log4j-core extends the existing APACHE logging utility functions log4j-api extends the existing APACHE logging utility functions","title":"Standard Libraries"},{"location":"logging/","text":"A log file is a file that records either events that occur in an operating system or other software runs, or messages between different users of a communication software. Logging is the act of keeping a log. In the simplest case, messages are written to a single log file or output to the system out console. Logging is not required for QA Automation develop, but it is strongly encouraged. To facilitate this, the logging capabilities have been extended in the Maven pom.xml through the addition of Log4j2 libraries. Defining a default log class has been defined within the Basesetup.java file for automation but you may define your own log class as needed. initialize: Log = LogManager.getLogger(this.testName.getMethodName()); invoke: Log.info( RUNNING IN ENVIRONMENT: + baseUrl );","title":"Logging"},{"location":"method_visibility/","text":"When designing automation code, you will need to consider the function's access to package. Overview A good rule of thumb is to make everything (within reason) as private as possible. This makes your class more encapsulated, and allows for changing the internals of the class without affecting the code using your class. The following keywords available during development that you should consider are: public Any class/function may access the method/property. @Test public void AuthPing() { //Test a ping to the API endpoint response = RestAssured.given(). header( Content-Type , application/json ). when(). get( /api/ping ). then(). log().ifError(). statusCode(200). contentType( application/vnd.api+json ). extract().response(); response.prettyPrint(); this.markAsPassed(); } protected Only this class and any subclasses may access the method/property. protected void markAsPassed() { Log.info( *** TEST PASSED *** ); System.out.println( \\n\\n ); } private Only this class may access the method/property. It won't even be inherited. private Response getResponseInfo(String user, String pw) { JSONObject json = new JSONObject(). put( identity , user). put( password , pw); temp = json.toString(); final the final keyword (lowercase) is a non-access modifier applicable only to a variable, a method or a class. Any variable, method, or class with a 'final' designation cannot be changed once it has been assigned and used only for values that are to remain constant throughout the execution of the test suite. public final jsonOrgFileReader config = new jsonOrgFileReader(new File( config2.json ));","title":"Method Visibility"},{"location":"method_visibility/#overview","text":"A good rule of thumb is to make everything (within reason) as private as possible. This makes your class more encapsulated, and allows for changing the internals of the class without affecting the code using your class. The following keywords available during development that you should consider are:","title":"Overview"},{"location":"method_visibility/#public","text":"Any class/function may access the method/property. @Test public void AuthPing() { //Test a ping to the API endpoint response = RestAssured.given(). header( Content-Type , application/json ). when(). get( /api/ping ). then(). log().ifError(). statusCode(200). contentType( application/vnd.api+json ). extract().response(); response.prettyPrint(); this.markAsPassed(); }","title":"public"},{"location":"method_visibility/#protected","text":"Only this class and any subclasses may access the method/property. protected void markAsPassed() { Log.info( *** TEST PASSED *** ); System.out.println( \\n\\n ); }","title":"protected"},{"location":"method_visibility/#private","text":"Only this class may access the method/property. It won't even be inherited. private Response getResponseInfo(String user, String pw) { JSONObject json = new JSONObject(). put( identity , user). put( password , pw); temp = json.toString();","title":"private"},{"location":"method_visibility/#final","text":"the final keyword (lowercase) is a non-access modifier applicable only to a variable, a method or a class. Any variable, method, or class with a 'final' designation cannot be changed once it has been assigned and used only for values that are to remain constant throughout the execution of the test suite. public final jsonOrgFileReader config = new jsonOrgFileReader(new File( config2.json ));","title":"final"},{"location":"misc_rules/","text":"Conditionals and Comparisons Always test floating-point numbers as = or = relational operator, never use exact comparisons (= = or != ). No assumptions shall be made about the value of uninitialized variables, unless the language definition makes a clear statement about this. Never use implied processing.... always state clearly a conditional\u2019s intent Program Flow Interrupt handlers shall perform minimal processing, and shall be meticulously commented. In high-level languages, multiple exits from a unit are allowed if that avoids excessive control structure nesting. Multiple entries into a unit are not allowed. Variables and Values When data files are accessed in a tree-structured directory environment, the names of the file directories shall not be hardwired in the code; whenever possible, environment variables or some similar mechanism shall be used to provide exact directory names dynamically. LET ME REPEAT: HARDWIRING VARIABLES IS BAD libraries Use existing libraries defined in the pom.xml file whenever possible. If an outside library is required to be included in the test, include the pom.xml changes as a separate (but dependent) pull request from the original feature so that only feature code is necessary to be reviewed.","title":"Miscellaneous Rules for Coding"},{"location":"misc_rules/#conditionals-and-comparisons","text":"Always test floating-point numbers as = or = relational operator, never use exact comparisons (= = or != ). No assumptions shall be made about the value of uninitialized variables, unless the language definition makes a clear statement about this. Never use implied processing.... always state clearly a conditional\u2019s intent","title":"Conditionals and Comparisons"},{"location":"misc_rules/#program-flow","text":"Interrupt handlers shall perform minimal processing, and shall be meticulously commented. In high-level languages, multiple exits from a unit are allowed if that avoids excessive control structure nesting. Multiple entries into a unit are not allowed.","title":"Program Flow"},{"location":"misc_rules/#variables-and-values","text":"When data files are accessed in a tree-structured directory environment, the names of the file directories shall not be hardwired in the code; whenever possible, environment variables or some similar mechanism shall be used to provide exact directory names dynamically. LET ME REPEAT: HARDWIRING VARIABLES IS BAD","title":"Variables and Values"},{"location":"misc_rules/#libraries","text":"Use existing libraries defined in the pom.xml file whenever possible. If an outside library is required to be included in the test, include the pom.xml changes as a separate (but dependent) pull request from the original feature so that only feature code is necessary to be reviewed.","title":"libraries"},{"location":"naming/","text":"Classes Class names should be nouns in UpperCamelCase, with the first letter of every word capitalised. Use whole words \u2014 avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the long form, such as URL or HTML). example. class Raster {}; class ImageSprite {} Methods Methods should be verbs in lowerCamelCase or a multi-word name that begins with a verb in lowercase; that is, with the first letter lowercase and the first letters of subsequent words in uppercase. example. run(); runFast(); getBackground(); Variables Local variables, instance variables, and class variables are also written in lowerCamelCase. Variable names should not start with underscore (_) or dollar sign ($) characters, even though both are allowed. This is in contrast to other coding conventions that state that underscores should be used to prefix all instance variables. Variable names should be short yet meaningful. The choice of a variable name should be mnemonic \u2014 that is, designed to indicate to the casual observer the intent of its use. One-character variable names should be avoided except for temporary \"throwaway\" variables. Common names for temporary variables are i, j, k, m, and n for integers; c, d, and e for characters. example. int i; char c; float myWidth; Constants Constants should be written in uppercase characters separated by underscores. Constant names may also contain digits if appropriate, but not as the first character. example. static final int MAX_PARTICIPANTS = 10;","title":"Naming Standards and Conventions"},{"location":"naming/#classes","text":"Class names should be nouns in UpperCamelCase, with the first letter of every word capitalised. Use whole words \u2014 avoid acronyms and abbreviations (unless the abbreviation is much more widely used than the long form, such as URL or HTML). example. class Raster {}; class ImageSprite {}","title":"Classes"},{"location":"naming/#methods","text":"Methods should be verbs in lowerCamelCase or a multi-word name that begins with a verb in lowercase; that is, with the first letter lowercase and the first letters of subsequent words in uppercase. example. run(); runFast(); getBackground();","title":"Methods"},{"location":"naming/#variables","text":"Local variables, instance variables, and class variables are also written in lowerCamelCase. Variable names should not start with underscore (_) or dollar sign ($) characters, even though both are allowed. This is in contrast to other coding conventions that state that underscores should be used to prefix all instance variables. Variable names should be short yet meaningful. The choice of a variable name should be mnemonic \u2014 that is, designed to indicate to the casual observer the intent of its use. One-character variable names should be avoided except for temporary \"throwaway\" variables. Common names for temporary variables are i, j, k, m, and n for integers; c, d, and e for characters. example. int i; char c; float myWidth;","title":"Variables"},{"location":"naming/#constants","text":"Constants should be written in uppercase characters separated by underscores. Constant names may also contain digits if appropriate, but not as the first character. example. static final int MAX_PARTICIPANTS = 10;","title":"Constants"},{"location":"revision_version_control/","text":"Version Control System All automation files shall be placed in our distributed version control system under Git . Every dev and QA engineer has a working copy of the code and full change history on their local machine as well as available via github.com at https://github.com/creativedrive/qa-automation . Branching and Pull Requests Additionally, QA automation development shall follow the Git Flow . Code that is tested and ready to be distributed to the team shall be merged, tagged, and pushed to the MASTER branch. An excellent visual resource for understanding how the git flow process works can be found here: https://danielkummer.github.io/git-flow-cheatsheet/ . QA Engineers will start a new feature branch from the 'develop' branch by running the command git flow feature start FEATURE . Feature branch names are recommended to be lowercase but that is not strictly enforced at this time. When a feature is finished, a pull request shall be initiated via the github portal so that it may be reviewed before publishing.","title":"Revision and Version Control Systems"},{"location":"revision_version_control/#version-control-system","text":"All automation files shall be placed in our distributed version control system under Git . Every dev and QA engineer has a working copy of the code and full change history on their local machine as well as available via github.com at https://github.com/creativedrive/qa-automation .","title":"Version Control System"},{"location":"revision_version_control/#branching-and-pull-requests","text":"Additionally, QA automation development shall follow the Git Flow . Code that is tested and ready to be distributed to the team shall be merged, tagged, and pushed to the MASTER branch. An excellent visual resource for understanding how the git flow process works can be found here: https://danielkummer.github.io/git-flow-cheatsheet/ . QA Engineers will start a new feature branch from the 'develop' branch by running the command git flow feature start FEATURE . Feature branch names are recommended to be lowercase but that is not strictly enforced at this time. When a feature is finished, a pull request shall be initiated via the github portal so that it may be reviewed before publishing.","title":"Branching and Pull Requests"},{"location":"test_order/","text":"Generally speaking, tests should not be dependent on running in a specific order. Test should be able to be run in a stand-alone fashion or in conjunction with others. However, under some conditions, a test execution order may be necessary There are 2 methods that can control an order of execution for test methods. FixMethodOrder SuiteClasses FixMethodOrder Test execution order can be defined by the @FixMethodOrder keyword value within the test suite. By invoking the keyword along with a method sorter variable, tests will be executed that fashion. For example, this will run tests in alphabetical ascending name order import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.rules.TestName; import org.junit.runners.MethodSorters; @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class ShareAPITests { ... } Suite Classes Another method for controlling the test execution order is by suite classes. Within the test suite, you define your suite class as follows: @RunWith(Suite.class) @Suite.SuiteClasses({Test1.class, Test2.class, Test3.class, Test4.class, Test5.class }) public class TestSuite { ... }","title":"Test Order Execution"},{"location":"test_order/#fixmethodorder","text":"Test execution order can be defined by the @FixMethodOrder keyword value within the test suite. By invoking the keyword along with a method sorter variable, tests will be executed that fashion. For example, this will run tests in alphabetical ascending name order import org.junit.FixMethodOrder; import org.junit.Test; import org.junit.rules.TestName; import org.junit.runners.MethodSorters; @FixMethodOrder(MethodSorters.NAME_ASCENDING) public class ShareAPITests { ... }","title":"FixMethodOrder"},{"location":"test_order/#suite-classes","text":"Another method for controlling the test execution order is by suite classes. Within the test suite, you define your suite class as follows: @RunWith(Suite.class) @Suite.SuiteClasses({Test1.class, Test2.class, Test3.class, Test4.class, Test5.class }) public class TestSuite { ... }","title":"Suite Classes"}]}